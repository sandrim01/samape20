// Quando executado pelo Electron, os módulos estão disponíveis diretamente
const electronModule = require('electron');
console.log('DEBUG: electronModule type:', typeof electronModule);
console.log('DEBUG: electronModule:', electronModule);

const { app, BrowserWindow, ipcMain } = electronModule;
console.log('DEBUG: app:', app);
console.log('DEBUG: BrowserWindow:', BrowserWindow);

const path = require('path');
const fs = require('fs');
const bcrypt = require('bcryptjs');

let mainWindow;
let dbPath;
let db;
const initialDB = {
  usuarios: [],
  clientes: [],
  maquinas: [],
  ordens_servico: [],
  pecas: [],
  vendas_pecas: [],
  itens_venda: [],
  itens_os: [],
  contas_receber: [],
  contas_pagar: [],
  counters: {
    usuarios: 0,
    clientes: 0,
    maquinas: 0,
    ordens_servico: 0,
    pecas: 0,
    vendas_pecas: 0,
    itens_venda: 0,
    itens_os: 0,
    contas_receber: 0,
    contas_pagar: 0
  }
};

// Funções de banco de dados
function initializePaths() {
  if (!dbPath) {
    dbPath = path.join(app.getPath('userData'), 'samapeop-data.json');
  }
}

function loadDatabase() {
  initializePaths();
  try {
    if (fs.existsSync(dbPath)) {
      const data = fs.readFileSync(dbPath, 'utf8');
      db = JSON.parse(data);
      console.log('Banco de dados carregado de:', dbPath);
    } else {
      db = { ...initialDB };
      saveDatabase();
      console.log('Novo banco de dados criado em:', dbPath);
    }
  } catch (error) {
    console.error('Erro ao carregar banco de dados:', error);
    db = { ...initialDB };
  }
}

function saveDatabase() {
  try {
    fs.writeFileSync(dbPath, JSON.stringify(db, null, 2), 'utf8');
  } catch (error) {
    console.error('Erro ao salvar banco de dados:', error);
  }
}

function getNextId(table) {
  db.counters[table]++;
  saveDatabase();
  return db.counters[table];
}

// Inicializar banco de dados
function initDatabase() {
  loadDatabase();

  // Criar usuário administrador padrão se não existir
  const adminExists = db.usuarios.find(u => u.email === 'admin@samapeop.com');

  if (!adminExists) {
    const hashedPassword = bcrypt.hashSync('admin123', 10);
    db.usuarios.push({
      id: getNextId('usuarios'),
      nome: 'Administrador',
      email: 'admin@samapeop.com',
      senha: hashedPassword,
      cargo: 'ADMIN',
      ativo: 1,
      criado_em: new Date().toISOString()
    });
    saveDatabase();
    console.log('Usuário administrador criado: admin@samapeop.com / admin123');
  }
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    autoHideMenuBar: true,
    icon: path.join(__dirname, 'resources/icon.svg')
  });

  mainWindow.loadFile('index.html');

  // Abrir DevTools em desenvolvimento
  // mainWindow.webContents.openDevTools();
}

app.whenReady().then(() => {
  initDatabase();
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// ==================== IPC HANDLERS ====================

// Autenticação
ipcMain.handle('login', async (event, { email, senha }) => {
  try {
    const usuario = db.usuarios.find(u => u.email === email && u.ativo === 1);

    if (!usuario) {
      return { success: false, message: 'Usuário não encontrado ou inativo' };
    }

    const senhaValida = bcrypt.compareSync(senha, usuario.senha);

    if (!senhaValida) {
      return { success: false, message: 'Senha incorreta' };
    }

    // Não enviar a senha de volta
    const { senha: _, ...usuarioSemSenha } = usuario;

    return { success: true, usuario: usuarioSemSenha };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Usuários
ipcMain.handle('criar-usuario', async (event, dados) => {
  try {
    const hashedPassword = bcrypt.hashSync(dados.senha, 10);
    const novoUsuario = {
      id: getNextId('usuarios'),
      nome: dados.nome,
      email: dados.email,
      senha: hashedPassword,
      cargo: dados.cargo,
      ativo: 1,
      criado_em: new Date().toISOString()
    };

    db.usuarios.push(novoUsuario);
    saveDatabase();

    return { success: true, id: novoUsuario.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-usuarios', async () => {
  try {
    const usuarios = db.usuarios.map(({ senha, ...u }) => u);
    return { success: true, usuarios };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('atualizar-usuario', async (event, { id, dados }) => {
  try {
    const index = db.usuarios.findIndex(u => u.id === id);
    if (index === -1) {
      return { success: false, message: 'Usuário não encontrado' };
    }

    if (dados.nome) db.usuarios[index].nome = dados.nome;
    if (dados.email) db.usuarios[index].email = dados.email;
    if (dados.cargo) db.usuarios[index].cargo = dados.cargo;
    if (dados.senha) db.usuarios[index].senha = bcrypt.hashSync(dados.senha, 10);
    if (dados.ativo !== undefined) db.usuarios[index].ativo = dados.ativo;

    saveDatabase();
    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Clientes
ipcMain.handle('criar-cliente', async (event, dados) => {
  try {
    const novoCliente = {
      id: getNextId('clientes'),
      nome: dados.nome,
      cnpj: dados.cnpj,
      telefone: dados.telefone,
      email: dados.email,
      endereco: dados.endereco,
      criado_em: new Date().toISOString()
    };

    db.clientes.push(novoCliente);
    saveDatabase();

    return { success: true, id: novoCliente.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-clientes', async () => {
  try {
    const clientes = [...db.clientes].sort((a, b) => a.nome.localeCompare(b.nome));
    return { success: true, clientes };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Máquinas
ipcMain.handle('criar-maquina', async (event, dados) => {
  try {
    const novaMaquina = {
      id: getNextId('maquinas'),
      cliente_id: parseInt(dados.cliente_id),
      modelo: dados.modelo,
      numero_serie: dados.numero_serie,
      ano: dados.ano ? parseInt(dados.ano) : null,
      observacoes: dados.observacoes,
      criado_em: new Date().toISOString()
    };

    db.maquinas.push(novaMaquina);
    saveDatabase();

    return { success: true, id: novaMaquina.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-maquinas', async (event, cliente_id) => {
  try {
    let maquinas = db.maquinas.map(m => {
      const cliente = db.clientes.find(c => c.id === m.cliente_id);
      return {
        ...m,
        cliente_nome: cliente ? cliente.nome : null
      };
    });

    if (cliente_id) {
      maquinas = maquinas.filter(m => m.cliente_id === cliente_id);
    }

    return { success: true, maquinas };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Ordens de Serviço
ipcMain.handle('criar-os', async (event, dados) => {
  try {
    const ano = new Date().getFullYear();
    const ordensDoAno = db.ordens_servico.filter(os =>
      os.numero_os.startsWith(`OS-${ano}-`)
    );
    const numeroSequencial = ordensDoAno.length + 1;
    const numero_os = `OS-${ano}-${numeroSequencial.toString().padStart(5, '0')}`;

    const novaOS = {
      id: getNextId('ordens_servico'),
      numero_os,
      cliente_id: parseInt(dados.cliente_id),
      maquina_id: parseInt(dados.maquina_id),
      mecanico_id: parseInt(dados.mecanico_id),
      descricao_problema: dados.descricao_problema,
      diagnostico: null,
      solucao: null,
      status: 'ABERTA',
      data_abertura: new Date().toISOString(),
      data_fechamento: null,
      valor_mao_obra: 0,
      valor_pecas: 0,
      valor_total: 0
    };

    db.ordens_servico.push(novaOS);
    saveDatabase();

    return { success: true, id: novaOS.id, numero_os };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-os', async (event, filtros = {}) => {
  try {
    let ordens = db.ordens_servico.map(os => {
      const cliente = db.clientes.find(c => c.id === os.cliente_id);
      const maquina = db.maquinas.find(m => m.id === os.maquina_id);
      const mecanico = db.usuarios.find(u => u.id === os.mecanico_id);

      return {
        ...os,
        cliente_nome: cliente ? cliente.nome : null,
        maquina_modelo: maquina ? maquina.modelo : null,
        mecanico_nome: mecanico ? mecanico.nome : null
      };
    });

    if (filtros.status) {
      ordens = ordens.filter(os => os.status === filtros.status);
    }

    if (filtros.mecanico_id) {
      ordens = ordens.filter(os => os.mecanico_id === filtros.mecanico_id);
    }

    ordens.sort((a, b) => new Date(b.data_abertura) - new Date(a.data_abertura));

    return { success: true, ordens };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('atualizar-os', async (event, { id, dados }) => {
  try {
    const index = db.ordens_servico.findIndex(os => os.id === id);
    if (index === -1) {
      return { success: false, message: 'OS não encontrada' };
    }

    if (dados.diagnostico !== undefined) db.ordens_servico[index].diagnostico = dados.diagnostico;
    if (dados.solucao !== undefined) db.ordens_servico[index].solucao = dados.solucao;
    if (dados.status) {
      db.ordens_servico[index].status = dados.status;
      if (dados.status === 'FECHADA') {
        db.ordens_servico[index].data_fechamento = new Date().toISOString();
      }
    }
    if (dados.valor_mao_obra !== undefined) db.ordens_servico[index].valor_mao_obra = parseFloat(dados.valor_mao_obra);

    // Recalcular valor total
    const os = db.ordens_servico[index];
    os.valor_total = (os.valor_mao_obra || 0) + (os.valor_pecas || 0);

    saveDatabase();
    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Peças
ipcMain.handle('criar-peca', async (event, dados) => {
  try {
    const novaPeca = {
      id: getNextId('pecas'),
      codigo: dados.codigo,
      descricao: dados.descricao,
      preco_custo: parseFloat(dados.preco_custo) || 0,
      preco_venda: parseFloat(dados.preco_venda) || 0,
      estoque_atual: parseInt(dados.estoque_atual) || 0,
      estoque_minimo: parseInt(dados.estoque_minimo) || 0,
      criado_em: new Date().toISOString()
    };

    db.pecas.push(novaPeca);
    saveDatabase();

    return { success: true, id: novaPeca.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-pecas', async () => {
  try {
    const pecas = [...db.pecas].sort((a, b) => a.descricao.localeCompare(b.descricao));
    return { success: true, pecas };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('atualizar-estoque', async (event, { id, quantidade }) => {
  try {
    const index = db.pecas.findIndex(p => p.id === id);
    if (index === -1) {
      return { success: false, message: 'Peça não encontrada' };
    }

    db.pecas[index].estoque_atual += parseInt(quantidade);
    saveDatabase();

    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Vendas de Peças
ipcMain.handle('criar-venda', async (event, dados) => {
  try {
    const ano = new Date().getFullYear();
    const vendasDoAno = db.vendas_pecas.filter(v =>
      v.numero_venda.startsWith(`VD-${ano}-`)
    );
    const numeroSequencial = vendasDoAno.length + 1;
    const numero_venda = `VD-${ano}-${numeroSequencial.toString().padStart(5, '0')}`;

    const novaVenda = {
      id: getNextId('vendas_pecas'),
      numero_venda,
      cliente_id: parseInt(dados.cliente_id),
      vendedor_id: parseInt(dados.vendedor_id),
      data_venda: new Date().toISOString(),
      valor_total: 0,
      status: 'PENDENTE'
    };

    db.vendas_pecas.push(novaVenda);
    saveDatabase();

    return { success: true, id: novaVenda.id, numero_venda };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('adicionar-item-venda', async (event, { venda_id, peca_id, quantidade }) => {
  try {
    const peca = db.pecas.find(p => p.id === peca_id);

    if (!peca) {
      return { success: false, message: 'Peça não encontrada' };
    }

    if (peca.estoque_atual < quantidade) {
      return { success: false, message: 'Estoque insuficiente' };
    }

    const subtotal = peca.preco_venda * quantidade;

    const novoItem = {
      id: getNextId('itens_venda'),
      venda_id: parseInt(venda_id),
      peca_id: parseInt(peca_id),
      quantidade: parseInt(quantidade),
      preco_unitario: peca.preco_venda,
      subtotal
    };

    db.itens_venda.push(novoItem);

    // Atualizar estoque
    const pecaIndex = db.pecas.findIndex(p => p.id === peca_id);
    db.pecas[pecaIndex].estoque_atual -= quantidade;

    // Atualizar valor total da venda
    const vendaIndex = db.vendas_pecas.findIndex(v => v.id === venda_id);
    const itensVenda = db.itens_venda.filter(i => i.venda_id === venda_id);
    db.vendas_pecas[vendaIndex].valor_total = itensVenda.reduce((sum, item) => sum + item.subtotal, 0);

    saveDatabase();

    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-vendas', async () => {
  try {
    const vendas = db.vendas_pecas.map(v => {
      const cliente = db.clientes.find(c => c.id === v.cliente_id);
      const vendedor = db.usuarios.find(u => u.id === v.vendedor_id);

      return {
        ...v,
        cliente_nome: cliente ? cliente.nome : null,
        vendedor_nome: vendedor ? vendedor.nome : null
      };
    }).sort((a, b) => new Date(b.data_venda) - new Date(a.data_venda));

    return { success: true, vendas };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Financeiro - Contas a Receber
ipcMain.handle('criar-conta-receber', async (event, dados) => {
  try {
    const novaConta = {
      id: getNextId('contas_receber'),
      cliente_id: dados.cliente_id ? parseInt(dados.cliente_id) : null,
      os_id: dados.os_id ? parseInt(dados.os_id) : null,
      venda_id: dados.venda_id ? parseInt(dados.venda_id) : null,
      valor: parseFloat(dados.valor),
      data_vencimento: dados.data_vencimento,
      data_pagamento: null,
      status: 'PENDENTE',
      observacoes: dados.observacoes
    };

    db.contas_receber.push(novaConta);
    saveDatabase();

    return { success: true, id: novaConta.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-contas-receber', async (event, filtros = {}) => {
  try {
    let contas = db.contas_receber.map(c => {
      const cliente = db.clientes.find(cl => cl.id === c.cliente_id);
      return {
        ...c,
        cliente_nome: cliente ? cliente.nome : null
      };
    });

    if (filtros.status) {
      contas = contas.filter(c => c.status === filtros.status);
    }

    contas.sort((a, b) => new Date(a.data_vencimento) - new Date(b.data_vencimento));

    return { success: true, contas };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('registrar-pagamento-receber', async (event, { id, data_pagamento }) => {
  try {
    const index = db.contas_receber.findIndex(c => c.id === id);
    if (index === -1) {
      return { success: false, message: 'Conta não encontrada' };
    }

    db.contas_receber[index].status = 'PAGO';
    db.contas_receber[index].data_pagamento = data_pagamento;

    saveDatabase();
    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Financeiro - Contas a Pagar
ipcMain.handle('criar-conta-pagar', async (event, dados) => {
  try {
    const novaConta = {
      id: getNextId('contas_pagar'),
      fornecedor: dados.fornecedor,
      descricao: dados.descricao,
      valor: parseFloat(dados.valor),
      data_vencimento: dados.data_vencimento,
      data_pagamento: null,
      status: 'PENDENTE',
      categoria: dados.categoria,
      observacoes: dados.observacoes
    };

    db.contas_pagar.push(novaConta);
    saveDatabase();

    return { success: true, id: novaConta.id };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('listar-contas-pagar', async (event, filtros = {}) => {
  try {
    let contas = [...db.contas_pagar];

    if (filtros.status) {
      contas = contas.filter(c => c.status === filtros.status);
    }

    contas.sort((a, b) => new Date(a.data_vencimento) - new Date(b.data_vencimento));

    return { success: true, contas };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

ipcMain.handle('registrar-pagamento-pagar', async (event, { id, data_pagamento }) => {
  try {
    const index = db.contas_pagar.findIndex(c => c.id === id);
    if (index === -1) {
      return { success: false, message: 'Conta não encontrada' };
    }

    db.contas_pagar[index].status = 'PAGO';
    db.contas_pagar[index].data_pagamento = data_pagamento;

    saveDatabase();
    return { success: true };
  } catch (error) {
    return { success: false, message: error.message };
  }
});

// Dashboard - Estatísticas
ipcMain.handle('obter-estatisticas', async () => {
  try {
    const stats = {
      os_abertas: db.ordens_servico.filter(os => os.status === 'ABERTA').length,
      os_em_andamento: db.ordens_servico.filter(os => os.status === 'EM_ANDAMENTO').length,
      contas_receber_pendentes: {
        count: db.contas_receber.filter(c => c.status === 'PENDENTE').length,
        total: db.contas_receber.filter(c => c.status === 'PENDENTE').reduce((sum, c) => sum + c.valor, 0)
      },
      contas_pagar_pendentes: {
        count: db.contas_pagar.filter(c => c.status === 'PENDENTE').length,
        total: db.contas_pagar.filter(c => c.status === 'PENDENTE').reduce((sum, c) => sum + c.valor, 0)
      },
      pecas_estoque_baixo: db.pecas.filter(p => p.estoque_atual <= p.estoque_minimo).length,
      vendas_mes: (() => {
        const hoje = new Date();
        const mesAtual = hoje.getMonth();
        const anoAtual = hoje.getFullYear();
        const vendasMes = db.vendas_pecas.filter(v => {
          const dataVenda = new Date(v.data_venda);
          return dataVenda.getMonth() === mesAtual && dataVenda.getFullYear() === anoAtual;
        });
        return {
          count: vendasMes.length,
          total: vendasMes.reduce((sum, v) => sum + v.valor_total, 0)
        };
      })()
    };

    return { success: true, stats };
  } catch (error) {
    return { success: false, message: error.message };
  }
});
